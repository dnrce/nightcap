#!/usr/bin/env python
# nightcap, a utility to put an idle server to sleep
# Copyright (C) 2014 Daniel Rice
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import os
import re
import signal
from subprocess import call, check_output
import sys
import time

timeout = 300

router = '192.168.0.18'

def pre_sleep():
  call(['ssh', '-q', router, 'iptables -A FORWARD -d 192.168.0.32 -s 192.168.0.0/24 -j ACCEPT'])
  call(['ssh', '-q', router, 'iptables -A FORWARD -d 192.168.0.32 -p udp --dport 1194 -j ACCEPT'])
  call(['ssh', '-q', router, 'iptables -A FORWARD -d 192.168.0.32 -j LOG'])
  call(['ssh', '-q', router, 'iptables -A FORWARD -d 192.168.0.32 -j REJECT'])

def post_sleep():
  check_output(['ssh', '-q', router, 'grep "user\.warn" /tmp/var/log/messages | tail'])
  call(['ssh', '-q', router, 'iptables -D FORWARD -d 192.168.0.32 -j REJECT'])
  call(['ssh', '-q', router, 'iptables -D FORWARD -d 192.168.0.32 -j LOG'])
  call(['ssh', '-q', router, 'iptables -D FORWARD -d 192.168.0.32 -p udp --dport 1194 -j ACCEPT'])
  call(['ssh', '-q', router, 'iptables -D FORWARD -d 192.168.0.32 -s 192.168.0.0/24 -j ACCEPT'])

def raid_clean():
  f = open('/proc/mdstat')
  mdstat = f.readlines()
  f.close()
  for line in mdstat:
    if re.match('\s*\[', line):
      return False
    m = re.search('\[[U_]+\]$', line)
    if m:
      if '_' in m.group(0):
        return False
  return True

def active_user_sessions():
  f = os.popen('who -q | tail -n1 | grep -o "[0-9]*"')
  NUM_USERS_LOGGED_IN = int(f.readline())
  return NUM_USERS_LOGGED_IN > 0:

def network_active():
  f = os.popen('pgrep -f transmission-daemon')
  TRANSMISSION_PID = int(f.readline())
  f = os.popen('pgrep -f CrashPlanService')
  CRASHPLAN_PID = int(f.readline())
  f = os.popen('netstat -np --inet | tail -n +3 | grep -v "127\.0\.0\.1\| %i\/\| %i\/" | wc -l' % (TRANSMISSION_PID, CRASHPLAN_PID))
  NUM_ACTIVE_CONNECTIONS = int(f.read())
  return NUM_ACTIVE_CONNECTIONS > 0

def safe_to_sleep():
  if not raid_clean():
    log("Unclean RAID device(s)")
    return False

  if active_user_sessions():
    log("Active user session(s)")
    return False

  if network_active():
    log("Connections are active")
    return False

  return True

def log(message):
  print time.strftime('%c'), message

def reset_timer():
  global timestamp
  timestamp = time.time()

def timed_out():
  current = time.time()
  return current-timestamp > timeout

def quit(signum, frame):
  sys.exit()

signal.signal(signal.SIGINT, quit)
signal.signal(signal.SIGTERM, quit)

# initialize the timer
reset_timer()

# main program logic
while 1:
  if safe_to_sleep():
    log("Idle, waiting for timeout")
    if timed_out:
      log("Sleeping...")
      pre_sleep()
      call(['/usr/sbin/pm-suspend'])
      log("Wake up")
      reset_timer()
      post_sleep()
  else:
    reset_timer()
  time.sleep(30)
