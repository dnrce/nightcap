#!/bin/bash
# nightcap, a utility to put an idle server to sleep
# Copyright (C) 2014 Daniel Rice
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

TIMEOUT=300

pre_sleep () {
  ssh -q 192.168.0.18 "iptables -A FORWARD -p udp -d 192.168.0.32 --dport 43971 -j DROP"
  ssh -q 192.168.0.18 "iptables -A FORWARD -d 192.168.0.32 -j LOG"
}

post_sleep () {
  ssh -q 192.168.0.18 "grep 'user\.warn' /tmp/var/log/messages | tail"
  ssh -q 192.168.0.18 "iptables -D FORWARD -d 192.168.0.32 -j LOG"
  ssh -q 192.168.0.18 "iptables -D FORWARD -p udp -d 192.168.0.32 --dport 43971 -j DROP"
}

# utility functions to make the logic easier to read
safe_to_sleep() {
  UNCLEAN_RAID_DEVICES=$(cat /sys/block/md*/md/array_state | grep -v "^clean$\|^active$" | wc -l)
  if [[ "$UNCLEAN_RAID_DEVICES" -gt "0" ]]; then
    log "Unclean RAID device(s)"
    return 1
  fi

  NUM_USERS_LOGGED_IN=$(who -q | tail -n1 | grep -o "[0-9]*")
  if [[ "$NUM_USERS_LOGGED_IN" -gt "0" ]]; then
    log "Active user session(s)"
    return 1
  fi

  TRANSMISSION_PID=$(pgrep -f transmission-daemon)
  CRASHPLAN_PID=$(pgrep -f CrashPlanService)
  NUM_ACTIVE_CONNECTIONS=$(netstat -np --inet | tail -n +3 | grep -v "127\.0\.0\.1\| $TRANSMISSION_PID\/\| $CRASHPLAN_PID\/" | wc -l)
  if [[ "$NUM_ACTIVE_CONNECTIONS" -gt "0" ]]; then
    log "Connections are active"
    return 1
  fi

  return 0
}

log() {
  echo "$(date) $1"
}

reset_timer() {
  TIMESTAMP=$(date +%s)
}

timed_out() {
  current=$(date +%s)
  [[ "$((current-TIMESTAMP))" -gt "$TIMEOUT" ]]
}

quit() {
  exit
}

trap quit SIGINT SIGTERM

# initialize the timer
reset_timer

# main program logic
while true; do
  if safe_to_sleep; then
    log "Idle, waiting for timeout"
    if timed_out; then
      log "Sleeping..."
      pre_sleep
      /usr/sbin/pm-suspend
      log "Wake up"
      reset_timer
      post_sleep
    fi
  else
    reset_timer
  fi
  sleep 30s
done
